/* Auto-generated (minimal) main.c - STM32F103C8T6 Induction Heater Prototype
   IMPORTANT: This is a lab/testing project template. Use low-voltage DC (12-48V) with a gate driver.
*/
#include "main.h"
#include "stm32f1xx_hal.h"
#include <string.h>

/* Application parameters */
float temp_setpoint = 150.0f;
float temp_input = 0.0f;
float pwm_duty = 0.0f;
float frequency_hz = 50000.0f;
float f_min = 30000.0f;
float f_max = 70000.0f;

/* PID */
float error = 0.0f;
float integral = 0.0f;
float Kp = 0.6f, Ki = 0.05f;
float integral_max = 200.0f;

/* Current sensing */
float current_voltage = 0.0f;
float current_trip_threshold = 2.5f;

/* Soft-start */
const float softstart_step = 1.0f;
const uint32_t softstart_delay_ms = 20;

/* Mode enum */
typedef enum {HEAT_LOW, HEAT_MED, HEAT_HIGH} HeatMode;
HeatMode mode = HEAT_MED;

/* HAL handles (defined/initialized in MX_... files) */
ADC_HandleTypeDef hadc1;
TIM_HandleTypeDef htim1;

/* Prototypes */
void read_temperature_and_current(void);
void update_mode(void);
void pid_control(void);
void set_pwm(float duty, float freq);
void soft_start(float target_duty, float freq);
void emergency_stop(void);
uint8_t button_pressed_debounced(GPIO_TypeDef* port, uint16_t pin);

/* Helper macro if not defined */
#ifndef __HAL_TIM_GET_PRESCALER
#define __HAL_TIM_GET_PRESCALER(__HANDLE__) ((__HANDLE__)->Instance->PSC)
#endif

int main(void)
{
    HAL_Init();
    SystemClock_Config();
    MX_GPIO_Init();
    MX_ADC1_Init();
    MX_TIM1_Init();

    HAL_TIM_PWM_Start(PWM_TIMER, PWM_CHANNEL);
    /* complementary output may not be needed on Blue Pill if not using CH1N */
    // HAL_TIMEx_PWMN_Start(PWM_TIMER, PWM_CHANNEL);

    soft_start(0.0f, frequency_hz);

    while (1)
    {
        if (HAL_GPIO_ReadPin(ESTOP_PORT, ESTOP_PIN) == GPIO_PIN_RESET) {
            emergency_stop();
        }

        read_temperature_and_current();
        update_mode();
        pid_control();
        set_pwm(pwm_duty, frequency_hz);

        if (current_voltage > current_trip_threshold) {
            __HAL_TIM_SET_COMPARE(PWM_TIMER, PWM_CHANNEL, 0);
            HAL_Delay(50);
            while (1) { } /* lock on fault */
        }

        HAL_Delay(10);
    }
}

/* ---------------- Functions ---------------- */

void read_temperature_and_current(void)
{
    ADC_ChannelConfTypeDef sConfig = {0};

    sConfig.Channel = TEMP_ADC_CHANNEL;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_71CYCLES_5;
    HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    HAL_ADC_Start(&hadc1);
    if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
        uint32_t adc_val = HAL_ADC_GetValue(&hadc1);
        float voltage = ((float)adc_val) * 3.3f / 4095.0f;
        temp_input = voltage * 100.0f;
    }
    HAL_ADC_Stop(&hadc1);

    sConfig.Channel = CURRENT_ADC_CHANNEL;
    sConfig.Rank = ADC_REGULAR_RANK_1;
    sConfig.SamplingTime = ADC_SAMPLETIME_71CYCLES_5;
    HAL_ADC_ConfigChannel(&hadc1, &sConfig);

    HAL_ADC_Start(&hadc1);
    if (HAL_ADC_PollForConversion(&hadc1, 10) == HAL_OK) {
        uint32_t adc_val = HAL_ADC_GetValue(&hadc1);
        current_voltage = ((float)adc_val) * 3.3f / 4095.0f;
    }
    HAL_ADC_Stop(&hadc1);
}

uint8_t button_pressed_debounced(GPIO_TypeDef* port, uint16_t pin)
{
    if (HAL_GPIO_ReadPin(port, pin) == GPIO_PIN_SET) {
        HAL_Delay(20);
        if (HAL_GPIO_ReadPin(port, pin) == GPIO_PIN_SET) {
            while (HAL_GPIO_ReadPin(port, pin) == GPIO_PIN_SET) { HAL_Delay(5); }
            return 1;
        }
    }
    return 0;
}

void update_mode(void)
{
    if (button_pressed_debounced(MODE_BTN_PORT, MODE_BTN_LOW)) {
        mode = HEAT_LOW; temp_setpoint = 100.0f; frequency_hz = 35000.0f;
    } else if (button_pressed_debounced(MODE_BTN_PORT, MODE_BTN_MED)) {
        mode = HEAT_MED; temp_setpoint = 150.0f; frequency_hz = 50000.0f;
    } else if (button_pressed_debounced(MODE_BTN_PORT, MODE_BTN_HIGH)) {
        mode = HEAT_HIGH; temp_setpoint = 200.0f; frequency_hz = 65000.0f;
    }
}

void pid_control(void)
{
    error = temp_setpoint - temp_input;
    integral += error * 0.01f;
    if (integral > integral_max) integral = integral_max;
    if (integral < -integral_max) integral = -integral_max;

    float output = Kp * error + Ki * integral;
    pwm_duty = output;
    if (pwm_duty > 90.0f) pwm_duty = 90.0f;
    if (pwm_duty < 0.0f) pwm_duty = 0.0f;

    frequency_hz += 0.02f * error;
    if (frequency_hz > f_max) frequency_hz = f_max;
    if (frequency_hz < f_min) frequency_hz = f_min;
}

void set_pwm(float duty, float freq)
{
    uint32_t period = __HAL_TIM_GET_AUTORELOAD(PWM_TIMER);
    uint32_t compare = (uint32_t)((float)period * (duty / 100.0f));
    __HAL_TIM_SET_COMPARE(PWM_TIMER, PWM_CHANNEL, compare);

    uint32_t prescaler = __HAL_TIM_GET_PRESCALER(PWM_TIMER);
    float timer_clk = (float)SystemCoreClock / (float)(prescaler + 1);
    uint32_t new_arr = (uint32_t)((timer_clk / freq)) - 1u;
    if (new_arr < 3u) new_arr = 3u;

    if (new_arr != period) {
        __HAL_TIM_DISABLE(PWM_TIMER);
        __HAL_TIM_SET_AUTORELOAD(PWM_TIMER, new_arr);
        uint32_t new_compare = (uint32_t)((float)new_arr * (duty / 100.0f));
        __HAL_TIM_SET_COMPARE(PWM_TIMER, PWM_CHANNEL, new_compare);
        __HAL_TIM_ENABLE(PWM_TIMER);
    }
}

void soft_start(float target_duty, float freq)
{
    float cur = 0.0f;
    for (; cur <= target_duty; cur += softstart_step) {
        set_pwm(cur, freq);
        HAL_Delay(softstart_delay_ms);
    }
    set_pwm(target_duty, freq);
}

void emergency_stop(void)
{
    __HAL_TIM_SET_COMPARE(PWM_TIMER, PWM_CHANNEL, 0);
    __HAL_TIM_DISABLE(PWM_TIMER);
    while (1) { }
}

/* ---------------- CubeMX stubs (minimal) ---------------- */

void SystemClock_Config(void) { /* Replace with CubeMX-generated clock config if available */ }

void MX_GPIO_Init(void)
{
    __HAL_RCC_GPIOC_CLK_ENABLE();
    __HAL_RCC_GPIOA_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};

    /* Buttons PC0, PC1, PC2 - input pull-down */
    GPIO_InitStruct.Pin = MODE_BTN_LOW | MODE_BTN_MED | MODE_BTN_HIGH;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    /* E-Stop PC3 - pull-up expected (active low) */
    GPIO_InitStruct.Pin = ESTOP_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_PULLUP;
    HAL_GPIO_Init(ESTOP_PORT, &GPIO_InitStruct);

    /* PWM output PA8 (TIM1_CH1) */
    GPIO_InitStruct.Pin = GPIO_PIN_8;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
}

void MX_ADC1_Init(void)
{
    __HAL_RCC_ADC1_CLK_ENABLE();
    hadc1.Instance = ADC1;
    hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
    hadc1.Init.ContinuousConvMode = DISABLE;
    hadc1.Init.DiscontinuousConvMode = DISABLE;
    hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
    hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
    hadc1.Init.NbrOfConversion = 1;
    HAL_ADC_Init(&hadc1);
}

void MX_TIM1_Init(void)
{
    __HAL_RCC_TIM1_CLK_ENABLE();
    htim1.Instance = TIM1;
    htim1.Init.Prescaler = 0;
    htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
    htim1.Init.Period = 719; /* example for 72MHz/720 -> 100 kHz base, will be adjusted */
    htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
    htim1.Init.RepetitionCounter = 0;
    HAL_TIM_PWM_Init(&htim1);

    TIM_OC_InitTypeDef sConfigOC = {0};
    sConfigOC.OCMode = TIM_OCMODE_PWM1;
    sConfigOC.Pulse = 0;
    sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
    sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
    sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
    sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
    sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;

    HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1);

    TIM_BreakDeadTimeConfigTypeDef sBreakConfig = {0};
    sBreakConfig.OffStateRunMode = TIM_OSSR_DISABLE;
    sBreakConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
    sBreakConfig.LockLevel = TIM_LOCKLEVEL_OFF;
    sBreakConfig.DeadTime = 72; /* example deadtime */
    sBreakConfig.BreakState = TIM_BREAK_DISABLE;
    sBreakConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
    sBreakConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
    HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakConfig);
}
